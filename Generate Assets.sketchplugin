// (ctrl cmd alt g)
// This command is a recreation of the Photoshop Generator functionality,
// introduced by Adobe on Photoshop CC <http://blogs.adobe.com/photoshopdotcom/2013/09/introducing-adobe-generator-for-photoshop-cc.html>

var generator = {
      version: "0.1",
      regexp: /\.png\d*\s*|\.jpg\d*\s*|\.gif\s*|\.svg\s*|\.eps\s*|\.pdf\s*|\.tif\s*|\d+%+|\d+\s*x\s*\d+/g
    },
    document_path = [[doc fileURL] path].split([doc displayName])[0],
    document_name = [doc displayName].replace(".sketch",""),
    assets_folder = document_path + "/" + document_name + "-assets",
    file_manager = [NSFileManager defaultManager],
    current_page_name,
    current_artboard_name,
    total_assets = 0;

Array.prototype.each = function(callback){
  var count = 0;
  for (var i = 0; i < this.length(); i++){
    var el = this[i];
    callback.call(this,el,count);
    count++;
  }
}

function process_layer(layer) {
  log('\t\tProcessing layer "' + [layer name] + '"');

  if(should_export(layer)) {
    // log("We should export it...");
    var layer_metadata = get_data_from_layer(layer);
    for(var i=0; i < layer_metadata.length; i++) {
      export_layer(layer, layer_metadata[i]);
    }
  };

  // Process sublayers
  if (is_group(layer)) {
    // log("Also, it's a group");
    var sublayers = [layer layers];
    sublayers.each(function(sublayer){
      process_layer(sublayer);
    });
  }
}
function should_export(layer) {
  // log("should_export(" + [layer name] + ")")
  return [layer name].match(generator.regexp);
}
function get_data_from_layer(layer) {

  log('\t\t\tGetting data from ' + layer);

  var name = [layer name],
      assets = name.split(","),
      assets_data = [];

  for (var i = 0; i < assets.length; i++) {

    var current_asset = assets[i],
        filename = current_asset.replace(generator.regexp,'').trim(),
        asset_metadata = {
          name: filename,
          filetype: current_asset.split(".")[1].substr(0,3),
          // TODO: Add support for '@2x' and 'HDPI' style scales
          scale: current_asset.match(/(\d+)%/) ? current_asset.match(/(\d+)%/)[1]/100.0 : 1.0
        }

    assets_data.push(asset_metadata);

  }
  return assets_data;
}
function sanitize_filename(name){
  return name.replace(/(\s+|\:|\/)/g ,"_");//.replace(/_+/g,"_");
}
function export_layer(layer, options) {
  log("\t\t\tExporting " + options.name + ", with scale: " + options.scale);

  var filename = assets_folder + "/" + sanitize_filename(current_page_name) + "/" + sanitize_filename(current_artboard_name) + "/" + sanitize_filename(options.name);

  // copy off-screen
  var copy = [layer duplicate];
  var frame = [copy frame];
  [frame setX:-100000];
  [frame setY:-100000];

  // export
  var rect = [copy rectByAccountingForStyleSize:[[copy absoluteRect] rect]],
      slice = [MSSlice sliceWithRect:rect scale:options.scale];

  // Look for '@bounds' layer
  if ([copy layers]) {
    log([copy name] + " has " + [[copy layers] length] + " sublayers")
    for(var i=0; i < [[copy layers] length]; i++){
      var sublayer = [copy layers][i];
      if([sublayer name] == '@bounds'){
        [sublayer setIsVisible:false];
      }
    }
  }
  // TODO: add scale in filename?
  // filename += "-" + options.scale + "x";
  [doc saveArtboardOrSlice:slice toFile:(filename + "." + options.filetype)];

  // Remove copy
  [copy removeFromParent];
  total_assets++;
}
function is_group(layer) {
  return [layer isMemberOfClass:[MSLayerGroup class]];
}
function cleanup(){
  if ([file_manager fileExistsAtPath:assets_folder]) {
    [file_manager removeItemAtPath:assets_folder error:nil];
  }
}

function main(){
  log("\r")
  log("#####################################################################################")
  log('# Sketch Generator running ##########################################################')
  log("#####################################################################################")
  log("\r")

  // HACK: on a freshly started Sketch instance, 'selection' is null until you select an object
  if (selection == null) {
    selection = [[NSArray alloc] init]
  }

  if ([selection length] > 0) {
    log("There's a selection, so export it instead of the whole document")
    current_page_name = [[doc currentPage] name];
    if ([[doc currentPage] artboards] > 0) {
      current_artboard_name = [[[doc currentPage] currentArtboard] name];
    } else {
      current_artboard_name = "no_artboard"
    }
    selection.each(function(layer){
      process_layer(layer);
    });
  } else {
    cleanup();

    // Traverse pages...
    [doc pages].each(function(page){

      [doc setCurrentPage:page];

      current_page_name = [[doc currentPage] name];

      log("-------------------------------------------------------------------------------------")
      log("Traversing page: " + current_page_name);

      // ...then artboards...
      var artboards = [[doc currentPage] artboards];

      if([artboards length] >= 1) {
        artboards.each(function(artboard){

          current_artboard_name = [artboard name];
          log("\tTraversing artboard " + current_artboard_name);

          // FIXME: don't export artboards named artboard.png inside a folder
          // i.e: export doc-assets/page_1/foo.png instead of doc-assets/page_1/foo.png/foo.png
          if(should_export(artboard)) {
            process_layer(artboard);
          }

          var all_layers = [artboard layers];
          all_layers.each(function(layer){
            process_layer(layer);
          });

        });
      } else {
        log("\tNo artboards in page...");
        current_artboard_name = 'no_artboard';
        var all_layers = [[doc currentPage] layers];
        all_layers.each(function(layer){
          process_layer(layer);
        });
      }
    });
  }
}

// Store start page, so we can return to it after exporting
var start_time = new Date(),
    start_page = [doc currentPage];

// Let's go!
main();

// Restore start page
[doc setCurrentPage:start_page];

// Some stats
[doc showMessage: "Sketch Generator: " + total_assets + " assets exported in " + ((new Date() - start_time) / 1000) + " seconds"];